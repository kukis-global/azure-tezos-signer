#!/usr/bin/env python3

###########################################################
# Written by Bo Byrd bo@tezzigator.com
# Copyright (c) 2019 Tezzigator LLC
# released under the MIT license
# most of this was actually written by Carl/Luke Youngblood
# of Blockscale, I just adapted it for MS Azure CloudHSM
###########################################################

from base64 import urlsafe_b64decode
from hashlib import blake2b, sha256
from base58 import b58encode
from requests import post, get
from json import loads
from os import path, environ
from json import loads

charenc = 'utf-8'
p2pk_magic =  bytes([3, 178, 139, 127])
p2hash_magic = bytes([6, 161, 164])
config = {
    'auth_front': 'https://login.microsoftonline.com/',
    'tenant_id': 'X',
    'auth_back': '/oauth2/v2.0/token',
    'webapp_id': 'X',
    'scope_url': 'https://vault.azure.net/.default',
    'vault_url': 'https://X.vault.azure.net',
    'keyname': 'X',
    'keyversion': 'X',
    'apiversion': '7.0',    
    'node_addr': 'http://127.0.0.1:8732',
    'aad_token': '',
    'token_expire': '',
    'keys': { 'tz3WaftwYXHatT1afD3XfAoaXcqKRuk2J4h9': { 'public_key': 'p2pk67ZmuqaUEamAyJsMWKSFwaWeEEe2nU2bnSrQcbyrH1h7Ub7uVpt' } }
}

print('Opening config.json')
if path.isfile('config.json'):
    print('Found config.json')
    with open('config.json', 'r') as myfile:
        json_blob = myfile.read().replace('\n', '')
        print('Parsed config.json successfully as JSON')
        config = loads(json_blob)

# get bearer auth token from AAD
print('authing to fetch bearer token... ', end='')
post_payload = {'client_id': config['webapp_id'], 'scope': config['scope_url'], 'client_secret': environ['WEBAPP_SECRET'], 'grant_type': 'client_credentials'}
post_headers = {'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json'}
response = post(config['auth_front'] + config['tenant_id'] + config['auth_back'], allow_redirects=False, headers=post_headers, data=post_payload)
config['aad_token'] = loads(response.text)['access_token']
print('success')

# get pubkey EC points
print('fetching public key XY coordinates...')
get_headers = {'Accept': 'application/json', 'Authorization': 'Bearer ' + config['aad_token']}
response = get(config['vault_url'] + '/keys/' + config['keyname'] + '/' + config['keyversion'] + '?api-version=' + config['apiversion'], allow_redirects=False, headers=get_headers)
x_coord = loads(response.text)['key']['x']
y_coord = loads(response.text)['key']['y']
print('x: ' + x_coord)
print('y: ' + y_coord)

# determine parity in Y coord - note that Azure has stripped off any padding that may have been there, we have to check and add it back
parity = bytes([2])
if int.from_bytes(urlsafe_b64decode(y_coord + "=" * ((4 - len(y_coord) % 4) % 4)), 'big') % 2 == 1:
    parity = bytes([3])
 
# generate p256 public key
pubkey = parity + urlsafe_b64decode(x_coord + "=" * ((4 - len(x_coord) % 4) % 4))

# double hash the public key with the prefix
hash = sha256(sha256(p2pk_magic + pubkey).digest()).digest()[:4]

# generic blake2b hash for the shorter pkhash
genhash = blake2b(pubkey, digest_size=20).digest()

# double hash the genhash with the pkhash prefix
hashpkh = sha256(sha256(p2hash_magic + genhash).digest()).digest()[:4]

print('pubkey: ' + b58encode(p2pk_magic + pubkey + hash).decode(charenc) + '\npkhash: ' + b58encode(p2hash_magic + genhash + hashpkh).decode(charenc))
